#!/usr/bin/env bash
# Main worktree workflow dispatcher

set -euo pipefail

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WT_ROOT="$(dirname "$SCRIPT_DIR")"

# Source shared libraries
# shellcheck source=../lib/wt-lib.sh
source "${WT_ROOT}/lib/wt-lib.sh"
# shellcheck source=../lib/abbreviations.sh
source "${WT_ROOT}/lib/abbreviations.sh"

# Show usage
show_usage() {
  cat <<EOF
wt - Worktree workflow manager

Usage: wt <command> [options]

Commands:
  init              Initialize worktree workflow in current repository
  status            Show uncommitted changes and worktree status
  create            Create a new worktree
  list              List all worktrees
  assign            Assign a file to a worktree
  assign-all        Assign all uncommitted changes to a worktree
  commit            Commit changes in a worktree
  undo              Undo last commit in a worktree
  unassign          Unassign a file from a worktree
  apply             Apply worktree commits to staging
  unapply           Unapply worktree commits from staging
  push              Push a worktree branch to remote
  pr                Open GitHub PR creation page for a worktree
  sync              Sync worktree-staging with main
  remove            Remove a worktree

Run 'wt <command> --help' for more information on a command.
EOF
}

# Find command by abbreviation
find_command() {
  local abbrev="$1"
  local found_command=""
  local match_count=0

  # Get all available commands
  for cmd_file in "${WT_ROOT}/commands"/*.sh; do
    local cmd_name
    cmd_name=$(basename "$cmd_file" .sh)

    # Check for exact match first
    if [[ "$cmd_name" == "$abbrev" ]]; then
      echo "$cmd_name"
      return 0
    fi

    # Check if command starts with abbreviation
    if [[ "$cmd_name" == "${abbrev}"* ]]; then
      found_command="$cmd_name"
      ((match_count++))
    fi
  done

  # If exactly one match, return it
  if [[ $match_count -eq 1 ]]; then
    echo "$found_command"
    return 0
  elif [[ $match_count -gt 1 ]]; then
    echo "Error: Ambiguous command '$abbrev'. Multiple matches found." >&2
    return 1
  else
    echo "Error: Unknown command '$abbrev'" >&2
    return 1
  fi
}

# Main dispatcher
main() {
  if [[ $# -eq 0 ]]; then
    show_usage
    exit 1
  fi

  local command_input="$1"
  shift

  # Find the actual command (supports abbreviations)
  local command
  command=$(find_command "$command_input")

  if [[ $? -ne 0 ]]; then
    echo >&2
    show_usage
    exit 1
  fi

  local command_script="${WT_ROOT}/commands/${command}.sh"

  if [[ ! -f "$command_script" ]]; then
    echo "Error: Command file not found for '$command'" >&2
    echo >&2
    show_usage
    exit 1
  fi

  # Source and execute the command
  # shellcheck source=/dev/null
  source "$command_script"

  # Call the command's main function (convention: cmd_<command>)
  local func_name="cmd_${command//-/_}"
  if declare -f "$func_name" > /dev/null; then
    "$func_name" "$@"
  else
    error "Command script '$command' does not define function '$func_name'"
  fi
}

main "$@"
